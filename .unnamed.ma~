(**************************************************************************)
(*       ___                                                              *)
(*      ||M||                                                             *)
(*      ||A||       A project by Andrea Asperti                           *)
(*      ||T||                                                             *)
(*      ||I||       Developers:                                           *)
(*      ||T||         The HELM team.                                      *)
(*      ||A||         http://helm.cs.unibo.it                             *)
(*      \   /                                                             *)
(*       \ /        This file is distributed under the terms of the       *)
(*        v         GNU General Public License Version 2                  *)
(*                                                                        *)
(**************************************************************************)

include "alpha.ma".

lemma dom_sse: ‚àÄe, y, y', H. ‚àÄx. domb_e x (sse e y y' H) = ((domb_e x e ‚àß ¬¨veqb x y) ‚à® (¬¨domb_e x e ‚àß domb_e y e ‚àß veqb x y')).
@Environment_simple_ind2 // #e * #z #b #HI #y #y' #H #x whd in match (sse ? ? ? ?);
whd in match (domb_e ? (Cons ? ?)); whd in match (domb_e ? (Cons ? ?));
cut (veqb y z = true ‚à® veqb y z = false) // * #Hyz >Hyz 
[ >if_t whd in match (domb_e ? ?); >HI normalize >if_then_true_else_false
  elim (veqb_true_to_eq y z) #Heq #_ lapply (Heq Hyz) -Heq #Heq destruct
  cut (veqb x z = true ‚à® veqb x z = false) // * #Hxz >Hxz
  [ >if_t >if_t >if_f >if_f elim (veqb_true_to_eq x z) #Heq #_ lapply (Heq Hxz) -Heq #Heq destruct
    >if_monotone >if_f lapply H normalize >veqb_simm cases veqb // >if_t
    >if_monotone #abs destruct
  | >if_f >if_f >if_then_true_else_false cases veqb normalize cases domb_e //
  ]
| >if_f >if_f whd in ‚ä¢ (? ? % ?); cut (veqb x z = true ‚à® veqb x z = false) // * #Hxz
  [ elim (veqb_true_to_eq x z) #Heq #_ lapply (Heq Hxz) -Heq #Heq destruct >Hxz
    >if_t >if_t >veqb_simm >Hyz normalize %
  | >Hxz >if_f >if_f >HI //
  ]
] qed.

lemma fvb_at: ‚àÄe, b, e', x. fvb x (at ‚å©b, e'‚å™ e) = ((fvb x ‚å©b, e'‚å™ ‚àß ¬¨ domb_e x e) ‚à® fvb_e x e).
@Environment_simple_ind2
[ #b #e #x normalize cases fvb_b cases fvb_e // cases domb_e //
| #e * #y #b' #HI #b #e' #x
  lapply (HI b e' x) normalize >domb_concat_distr >fv_concat normalize
  cut (veqb x y = true ‚à® veqb x y = false) // * #Hxy >Hxy normalize
  [ >if_monotone >if_monotone >if_monotone >if_f >if_f >if_f >if_monotone >if_f //
  | >if_then_true_else_false >if_then_true_else_false
    cases fvb_b normalize
    [ 2: #_ cases fvb_e // cases domb_e //
    | cases fvb_e cases domb_e // normalize
      [ #_ cases domb_e cases fvb_b //
      | cases domb_e //
      ]
    ]
  ]
] qed.

lemma fvb_ssc1:
 (‚àÄc, y, y', x. ‚àÄ(H). veqb x y' = false ‚Üí fvb x (ssc c y y' H) = (fvb x c ‚àß (¬¨veqb x y))) ‚àß
  (‚àÄb, y, y', x. ‚àÄ(H). veqb x y' = false ‚Üí fvb_b x (ssb b y y' H) = (fvb_b x b ‚àß (¬¨veqb x y))) ‚àß
   (‚àÄe, y, y', x. ‚àÄ(H). veqb x y' = false ‚Üí fvb_e x (sse e y y' H) = (fvb_e x e ‚àß (¬¨veqb x y))) ‚àß
    (‚àÄv, y, y', x. ‚àÄ(H). veqb x y' = false ‚Üí fvb_v x (ssv v y y' H) = (fvb_v x v ‚àß (¬¨veqb x y))) ‚àß
     (‚àÄs, y, y', x. ‚àÄ(H). veqb x y' = false ‚Üí fvb_s x (sss s y y' H) = (fvb_s x s ‚àß (¬¨veqb x y))).
@Crumble_mutual_ind
[ #b #e #Hb #He #y #y' #x #H1 #H2 whd in match (ssc ? ? ? ?);
  whd in match (fvb ? ?); >Hb // >He //
  cut (veqb x y = true ‚à® veqb x y = false) // * #Hxy >Hxy
  [ whd in match (andb ? false); >if_monotone
    whd in match (andb ? false); >if_monotone 
    whd in match (andb ? false); >if_monotone %
  | whd in match (andb ? true); >if_then_true_else_false
    whd in match (andb ? true); >if_then_true_else_false
    whd in match (andb ? true); >if_then_true_else_false >dom_sse >H2 >Hxy
    normalize cases fvb_b // cases domb_e // >if_monotone //
  ]
| #v #HI #y #y' #x #H #H1 @HI @H1
| #v #w #Hv #Hw #y #y' #x #H #H1 whd in match (ssb ? ? ? ?);
  whd in match (fvb_b ? ?); >Hv // >Hw // whd in match (fvb_b ? ?); cases fvb_v
  cases fvb_v // cases veqb //
| #z #y #y' #x #H #H1 normalize cut (veqb z y = true ‚à® veqb z y = false) // * #Hyz >Hyz
  normalize
  [ >H1 elim (veqb_true_to_eq z y) #Heq #_ lapply (Heq Hyz) -Heq #Heq destruct
    cases veqb //
  | cut (veqb x z = true ‚à® veqb x z = false) // * #Hxz >Hxz //
    elim (veqb_true_to_eq x z) #Heq #_ lapply (Heq Hxz) -Heq #Heq destruct >Hyz
    //
  ]
| #z #c #HI #y #y' #x #H #H1 whd in match (ssv ? ? ? ?);
  cut (veqb z y = true ‚à® veqb z y = false) // * #Hzy >Hzy
  [ >if_t normalize elim (veqb_true_to_eq z y) #Heq #_ lapply (Heq Hzy) -Heq #Heq
    destruct >veqb_simm cases veqb // cases fvb //
  | >if_f whd in match (((Œªp:inb_v y' (ùõåz.c)=false.ùõåz.ssc c y y' (alpha_lemma6 y' z c p)) H));
    whd in match (fvb_v ? ?); whd in match (fvb_v ? ?);
    cut (veqb z x = true ‚à® veqb z x = false) // * #Hzx >Hzx // >if_t >if_t
    >HI //
  ]
| //
| #e * #z #b' #He #Hs #y #y' #x #H #H1 whd in match (sse ? ? ? ?);
  cut (veqb y z = true ‚à® veqb y z = false) // * #Hyz >Hyz
  [ >if_t whd in match (((Œªp:inb_e y' (Cons e [z‚Üêb'])=false
    .Cons (sse e y y' (alpha_lemma8 y' e z b' p))
     [y'‚Üêssb b' y y' (alpha_lemma7 y' e z b' p)]) H));
  whd in match (fvb_e ? ?); >He //
  lapply (Hs y y' x ? H1)
  [ lapply H change with (orb ? ?) in match (inb_e ? ?);
    cases inb_s // whd in match (orb ? true); >if_monotone //
  | whd in match (sss ? ? ? ?);
    whd in match (fvb_s ? ?);
    cut (‚àÄZ, Z'. fvb_b x (ssb b' y y' Z)¬†= fvb_b x (ssb b' y y' Z')) [ // ]
    #Htmp >(Htmp ? (alpha_lemma7 ‚Ä¶ H)) #HH >HH normalize -Htmp -HH
    elim (veqb_true_to_eq ‚Ä¶ y z) #Heq #_ lapply (Heq Hyz) -Heq #Heq destruct
    cut (veqb x z = true ‚à® veqb x z = false) // * #Hxz >Hxz normalize
    [ >if_monotone >if_monotone >if_f //
    | >if_then_true_else_false >if_then_true_else_false >if_then_true_else_false
      >H1 >if_f cases fvb_e //
    ]
  ]
  | >if_f whd in match 
  ((Œªp:inb_e y' (Cons e [z‚Üêb'])=false
    .Cons (sse e y y' (alpha_lemma8 y' e z b' p))
     [z‚Üêssb b' y y' (alpha_lemma7 y' e z b' p)]) H);
    whd in match (fvb_e ? ?); whd in match (fvb_e ? (Cons ? ?)); >He //
    lapply (Hs y y' x ? H1)
  [ lapply H change with (orb ? ?) in match (inb_e ? ?);
    cases inb_s // whd in match (orb ? true); >if_monotone //
  | whd in match (sss ? ? ? ?);
    whd in match (fvb_s ? ?);
    cut (‚àÄZ, Z'. fvb_b x (ssb b' y y' Z)¬†= fvb_b x (ssb b' y y' Z')) [ // ]
    #Htmp >(Htmp ? (alpha_lemma7 ‚Ä¶ H)) #HH >HH -Htmp -HH
    whd in match (fvb_s ? ?);
    cases veqb
    [ whd in match (andb ? false); >if_monotone
      whd in match (andb ? false); >if_monotone
      whd in match (andb ? false); >if_monotone //
    | cases veqb
      [ whd in match (andb ? false); >if_monotone
        whd in match (andb ? false); >if_monotone //
      | whd in match (andb ? true); >if_then_true_else_false
        whd in match (andb ? true); >if_then_true_else_false
        whd in match (andb ? true); >if_then_true_else_false
        whd in match (andb ? true); >if_then_true_else_false //
      ]
    ]
  ]
  ]
| #z #b #HI #y #y' #x #H #H1 normalize >HI //
] qed. 
  
lemma alpha_fv_cons: ‚àÄe, b, n, H. ‚àÄx. fvb x (pi1 ‚Ä¶ (alpha b e n H)) = fvb x ‚å©b, e‚å™.
@Environment_simple_ind2
[ #b #n change with (max ? ?) in match (fresh_var ?); #H #x whd in match (alpha ? ? ? ?); //
| #e * * #y #b' #HI #b #n change with (max ? (max ? (max ? ?))) in match (fresh_var ?);
  #H #x whd in match (alpha ? ? ? ?); lapply (HI b (S n) (alpha_aux1 b e [ŒΩy‚Üêb'] n H) x)
  cases alpha * #ab #ae #hh whd in match (match ? in Sig with [_‚áí?]);
  change with (at (CCrumble b e) (Cons Epsilon [ŒΩy‚Üêb'])) in match (CCrumble b (Cons e [ŒΩy‚Üêb']));
  #HH <HH >fvb_at >fvb_at whd in match (fvb_e ? ?); whd in match (domb_e ? ?);
  whd in match (domb_e ? ?); >if_then_true_else_false
  whd in match (domb_e ? ?); whd in match (domb_e ? ?); >if_then_true_else_false
  cases fvb_b
  [ whd in match (orb ? true); >if_monotone
    whd in match (orb ? true); >if_monotone % ]
  whd in match (orb ? false); >if_then_true_else_false
  whd in match (orb ? false); >if_then_true_else_false <HH
  cut (veqb x (ŒΩn) = true ‚à® veqb x (ŒΩn) = false) // * #Hxn
  [ elim (veqb_true_to_eq ‚Ä¶ x ŒΩn) #Heq lapply (Heq Hxn) -Heq #Heq destruct #_
    >Hxn whd in match (notb true); whd in match (andb ? false); >if_monotone
    >HH
    cut (inb (ŒΩn)  ‚å©b,e‚å™ = false)
    [ lapply fresh_var_to_in_crumble * * * * #Hc #_ #_ #_ #_ @Hc 
      @to_max [ @(le_maxl ‚Ä¶ H) | @(le_maxl ‚Ä¶ (le_maxr ‚Ä¶ H)) ] ] #Hin
    cut (fvb (ŒΩn)  ‚å©b,e‚å™ = false)
    [ lapply Hin @bool_impl_inv2 lapply fv_to_in_crumble * * * * #Hc #_ #_ #_ #_
      @Hc ] -Hin #Hfv >Hfv whd in match (andb false ?); % ]
  lapply fvb_ssc1 * * * * #_ #Hb #He #_ #_
  whd in match (fvb ? ?); >Hb // >He //  >dom_sse cases veqb
  [ whd in match (andb ? false); >if_monotone
    whd in match (andb ? false); >if_monotone
    whd in match (andb ? false); >if_monotone
    whd in match (andb false ?); //
  | whd in match (andb ? true); >if_then_true_else_false
    whd in match (andb ? true); >if_then_true_else_false
    whd in match (andb ? true); >if_then_true_else_false
    whd in match (andb ? true); >if_then_true_else_false
    cases veqb
    [ whd in match (andb ? false); >if_monotone
  
  whd in match (ssc ? ? ? ?); whd in match (at ? ?); whd in match (concat ? ?);
  >concat_e_epsilon whd in match (fvb ? ?); whd in match (fvb ? ?);
  whd in match (fvb ? ?); whd in match (domb_e ? (Cons ? ?));
  whd in match (fvb_e ? (Cons ? ?));
  cut (veqb x (ŒΩn) = true ‚à® veqb x (ŒΩn) = false) // * #Hxn
  [ elim (veqb_true_to_eq ‚Ä¶ x ŒΩn) #Heq lapply (Heq Hxn) -Heq #Heq destruct #_
    >Hxn >if_t whd in match (notb true); whd in match (andb ? false);
    >if_monotone >if_f whd in match (andb ? false); >if_monotone >if_f #_
    cut (inb (ŒΩn)  ‚å©b,Cons e [ŒΩy‚Üêb']‚å™ = false)
    [ lapply fresh_var_to_in_crumble * * * * #Hc #_ #_ #_ #_ @Hc @H ] #Hin
    cut (fvb (ŒΩn)  ‚å©b,Cons e [ŒΩy‚Üêb']‚å™ = false)
    [ lapply Hin @bool_impl_inv2 lapply fv_to_in_crumble * * * * #Hc #_ #_ #_ #_
      @Hc ] -Hin #Hfv >Hfv lapply Hfv normalize cases (fvb_b ? b') //
    >if_monotone >if_monotone * %
  | >Hxn >if_f whd in match (¬¨false); whd in match (andb ? true);
    >if_then_true_else_false