(**************************************************************************)
(*       ___                                                              *)
(*      ||M||                                                             *)
(*      ||A||       A project by Andrea Asperti                           *)
(*      ||T||                                                             *)
(*      ||I||       Developers:                                           *)
(*      ||T||         The HELM team.                                      *)
(*      ||A||         http://helm.cs.unibo.it                             *)
(*      \   /                                                             *)
(*       \ /        This file is distributed under the terms of the       *)
(*        v         GNU General Public License Version 2                  *)
(*                                                                        *)
(**************************************************************************)

include "arithmetics/nat.ma".

let rec neqb n m ≝ 
 match n with
 [ O ⇒ match m with
       [ O ⇒ true 
       | S q ⇒ false
       ]
 |S p ⇒ match m with
       [ O ⇒ false
       | S q ⇒ neqb p q]]. 
(*
lemma max_comm_aux1: ∀x, y. leb x y= false → eqb x y = false → leb y x = true.
#x #y #H1 #H2 lapply (leb_false_to_not_le … H1) -H1 #H1
 lapply (eqb_false_to_not_eq … H2) -H2 #H2 cut (y ≤x)
 [ /3/  | #Hf /2/] qed.
 
lemma max_comm_aux2: ∀x, y. leb x y= true → eqb x y = false → leb y x = false.
#x #y #H1 #H2 lapply (leb_true_to_le … H1) -H1 #H1
 lapply (eqb_false_to_not_eq … H2) -H2 #H2 cut (y ≰ x)
 [ /3/  | #Hf /2/] qed.
     
lemma max_comm: ∀x, y. max x y = max y x.      
#x elim x
[ normalize #y cases y //
| #nx #H #y whd in match (max ? ?);
  whd in match (max y (S nx));
  cut (eqb (S nx) y = true ∨ eqb (S nx) y = false) // * #Heq
  [ lapply(eqb_true_to_eq … Heq) -Heq #Heq destruct //
  | cut (leb (S nx) y = true ∨ leb (S nx) y = false) // * #Hleb
   [ lapply (max_comm_aux2 … Hleb Heq) #Hwow >Hleb >Hwow normalize //
   | lapply (max_comm_aux1 … Hleb Heq) #Hwow >Hleb >Hwow normalize //
   ]
  ]
]
qed.
*)
lemma leb_true_to_leb_S: ∀x,y. (leb x y)=true → (leb (S x) (S y))=true.
#x #y normalize // qed.

lemma leb_false_to_leb_S: ∀x,y. (leb x y)=false → (leb (S x) (S y))=false.
#x #y normalize // qed.

  
lemma foo_aux: ∀x, y. max (S x) (S y) = S (max x y).
#x elim x
[ #y normalize //
| #nx #H #y whd in match (max ? ?) in ⊢ %;
  change with (S (if leb (S nx) y then y else (S nx))) in match (S (max (S nx) y)) in ⊢ %;
  cut (leb (S nx) y=true ∨ (leb (S nx) y)=false) // * #Htf
  [ lapply (leb_true_to_leb_S … Htf)  #Hwow >Hwow >Htf normalize //
  | lapply (leb_false_to_leb_S … Htf)  #Hwow >Hwow >Htf normalize //
  ]
]
qed.

lemma foo: ∀x,y. neqb x (max (S x) y)= false.
#x #y cut (leb x y = true ∨ leb x y = false) // * #Hleb normalize
change with (leb (S ?) ?) in match (match y in nat return λ_:ℕ.bool with [O⇒false|S (q:ℕ)⇒leb x q]);
cut (leb (S x) y= true ∨ leb (S x) y = false) // * #Hleb2
[>Hleb2 normalize 

