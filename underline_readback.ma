
(**************************************************************************)
(*       ___                                                              *)
(*      ||M||                                                             *)
(*      ||A||       A project by Andrea Asperti                           *)
(*      ||T||                                                             *)
(*      ||I||       Developers:                                           *)
(*      ||T||         The HELM team.                                      *)
(*      ||A||         http://helm.cs.unibo.it                             *)
(*      \   /                                                             *)
(*       \ /        This file is distributed under the terms of the       *)
(*        v         GNU General Public License Version 2                  *)
(*                                                                        *)
(**************************************************************************)

include "crumbles.ma".
include "variable finite set.ma".
include "basics/types.ma".

notation "[ term 19 v ‚Üê term 19 b ]" non associative with precedence 90 for @{ 'substitution $v $b }.
interpretation "Substitution" 'substitution v b =(subst v b).

(*notation "‚å© b break, e ‚å™" non associative with precedence 90 for @{ 'ccrumble $b $e }.
*)
interpretation "Crumble creation" 'pair b e =(CCrumble b e).

notation "ùõå x . y" right associative with precedence 40 for @{ 'lambda $x $y}.
interpretation "Abstraction" 'lambda x y = (lambda x y ).

notation "ŒΩ x" non associative with precedence 90 for @{ 'variable $x}.
interpretation "Variable contruction" 'variable x = (variable x).

notation "hvbox(c @ e)" with precedence 35 for @{ 'at $c $e }.
interpretation "@ operation" 'at c e =(at c e).

let rec domb x c on c ‚âù
 match c with
 [ CCrumble b e ‚áí domb_e x e ]

and domb_e x e on e ‚âù
 match e with
 [ Epsilon ‚áí false
 | Cons e s ‚áí match s with [ subst y b ‚áí (veqb x y) ‚à® (domb_e x e)]
 ].
 (*
definition Sig_fst ‚âù ŒªA:Type[0].ŒªP:A‚ÜíProp.Œªx:Sig A P.
 match x with [mk_Sig a h‚áía].

definition Sig_snd: ‚àÄA,P.‚àÄx:Sig A P.P(Sig_fst A P x) ‚âù ŒªA,P,x.
match x return Œªx.P(Sig_fst A P x) with [mk_Sig a h‚áíh].
*)

let rec free_occ_t x t on t ‚âù
 match t with
 [val_to_term v ‚áí free_occ_v x v
 |appl t1 t2 ‚áí (free_occ_t x t1)+(free_occ_t x t2)
 ]

and free_occ_v x v on v ‚âù
 match v with
 [ pvar y ‚áí match veqb x y with [ true ‚áí 1 | false ‚áí 0]
 | abstr y t ‚áí match (veqb x y) with [ true ‚áí 0 | false ‚áí (free_occ_t x t)]
 ]
.

let rec gtb n m on n ‚âù
 match n with
 [ O ‚áí false
 | S n' ‚áí match m with [ O ‚áí true | S m' ‚áí gtb n' m']
 ]
.

definition fv_t ‚âù Œªx.Œªt. (free_occ_t x t)>0.
definition fv_v ‚âù Œªx.Œªv. (free_occ_v x v)>0.
definition fvb_t ‚âù Œªx.Œªt. gtb (free_occ_t x t) 0.
definition fvb_v ‚âù Œªx.Œªv. gtb (free_occ_v x v) 0.

let rec fvb x c on c : bool ‚âù
 match c with
 [ CCrumble b e ‚áí ((fvb_b x b) ‚àß ¬¨(domb_e x e)) ‚à® fvb_e x e ]

and fvb_b x b on b ‚âù
 match b with
 [ CValue v ‚áí fvb_v x v
 | AppValue v w ‚áí (fvb_v x v) ‚à® (fvb_v x w)
 ]

and fvb_e x e on e ‚âù
 match e with
 [ Epsilon ‚áí false
 | Cons e s ‚áí match s with [subst y b ‚áí ((fvb_e y e) ‚àß (¬¨ veqb x y)) ‚à® fvb_b x b]
 ]

and fvb_v x v on v ‚âù
 match v with
 [ var y ‚áí veqb x y
 | lambda y c ‚áí (¬¨(veqb y x) ‚àß fvb x c)
 ]
 .

let rec fresh_var c on c ‚âù
 match c with
 [ CCrumble b e ‚áí  max (fresh_var_b b) (fresh_var_e e)]

and fresh_var_b b on b ‚âù
 match b with
 [ CValue v ‚áí fresh_var_v v
 | AppValue v w ‚áí max (fresh_var_v v) (fresh_var_v w)
 ]

and fresh_var_e e on e ‚âù
 match e with
 [ Epsilon ‚áí O
 | Cons e s ‚áí max (fresh_var_e e) (fresh_var_s s)
 ]

and fresh_var_v v on v ‚âù
 match v with
 [ var y ‚áí match y with [ variable x ‚áí S x ]
 | lambda y c ‚áí match y with [ variable x ‚áí max (S x) (fresh_var c)]
 ]

and fresh_var_s s on s ‚âù
 match s with
 [ subst x b ‚áí match x with [ variable x ‚áí max (S x) (fresh_var_b b)] ]
 .

let rec fresh_var_t t on t ‚âù
 match t with
 [ val_to_term v ‚áí fresh_var_tv v
 | appl v w ‚áí max (fresh_var_t v) (fresh_var_t w)
 ]

and fresh_var_tv v on v ‚âù
 match v with
 [ pvar v ‚áí match v with [variable x ‚áí S x]
 | abstr v t ‚áí match v with [variable x ‚áí max (S x) (fresh_var_t t)]
 ]
 .
(*
let rec fresh_var e ‚âù
 match e with
 [ Epsilon ‚áí  O
 | Cons e' s ‚áí  match s with [ subst v b ‚áí match v with [ variable n ‚áí max (S n) (fresh_var e')]]
 ]
 .

let rec underline_pifTerm (t: pifTerm) :Crumble ‚âù
 match t with
 [ val_to_term v ‚áí ‚å©CValue (overline v), Epsilon‚å™
 | appl t1 t2 ‚áí match t2 with
                [ val_to_term v2 ‚áí match t1 with
                                   [ val_to_term v1 ‚áí ‚å©AppValue (overline v1) (overline v2), Epsilon ‚å™
                                   | appl u1 u2 ‚áí match underline_pifTerm t1 with [CCrumble b e ‚áí ‚å©AppValue (var ŒΩ(fresh_var e)) (overline v2), push e [ŒΩ(fresh_var e)‚Üêb]‚å™]
                                   ]
                | appl u1 u2 ‚áí match underline_pifTerm t2 with [ CCrumble b e ‚áí at (underline_pifTerm (appl t1 (val_to_term (pvar ŒΩ(fresh_var e))))) (push e [ŒΩ(fresh_var e)‚Üêb]) ]
                ]
 ]
*)
(* deve restituire una coppia ‚å©crumble, numero di variabili gi√† inserite‚å™ per usare il parametro destro sommato al numero di variabili presenti nel termine all'inizio per dare sempre una variabile fresca*)

let rec underline_pifTerm (t: pifTerm) (s: nat): Crumble √ó nat‚âù
 match t with
 [ val_to_term v ‚áí match overline v s with
   [ mk_Prod vv n ‚áí  mk_Prod Crumble nat ‚å©(CValue vv), Epsilon ‚å™ n]
 | appl t1 t2 ‚áí match t2 with
   [ val_to_term v2 ‚áí match t1 with
     [ val_to_term v1 ‚áí match overline v1 s with
       [ mk_Prod vv n ‚áí match overline v2 (s+n) with
         [ mk_Prod ww m ‚áí mk_Prod Crumble nat ‚å©AppValue (vv) (ww), Epsilon‚å™ (m+n) ]
       ]
     | appl u1 u2 ‚áí match underline_pifTerm t1 s with
       [ mk_Prod c n ‚áí match c with
         [ CCrumble b e ‚áí match overline v2 (s+n) with
           [ mk_Prod vv m ‚áí mk_Prod Crumble nat ‚å©AppValue (var ŒΩ(s+n+m)) (vv), push e [(ŒΩ(s+n+m)) ‚Üê b]‚å™ (S (s+n+m))]
         ]
       ]
     ]
   | appl u1 u2 ‚áí match underline_pifTerm t2 s with
     [ mk_Prod c n ‚áí match c with
       [ CCrumble b1 e1 ‚áí match t1 with
         [ val_to_term v1 ‚áí match overline v1 (s+n) with
           [ mk_Prod vv m ‚áí  mk_Prod Crumble nat (at ‚å©AppValue (vv) (var ŒΩ(s+n+m)), Epsilon‚å™ (push e1 [ŒΩ(s+n)‚Üêb1])) (S n)]
         | appl u1 u2 ‚áí match underline_pifTerm t1 (s+n) with
          [ mk_Prod c1 n1 ‚áí match c1 with
            [ CCrumble b e ‚áí mk_Prod Crumble nat ‚å©AppValue (var (ŒΩ(s+n+n1))) (var (ŒΩ(S(s+n+n1)))), concat (push e1 [ŒΩ(s+n+n1) ‚Üê b1]) (push e [ŒΩ(S(s+n+n1)) ‚Üê b])‚å™ (S (S (s + n + n1)))]
          ]
         ]
       ]
     ]
   ]
 ]

and

overline (x:pifValue) (s: nat): Value √ó nat‚âù
 match x with
 [ pvar v ‚áí mk_Prod Value nat (var v) O
 | abstr v t ‚áí match underline_pifTerm t s with
   [ mk_Prod c n ‚áí mk_Prod Value nat (lambda (v) (c)) n ]
 ]
 .
 
let rec rename_aux (x: Variable) (x':Variable) (t:pifTerm) on t :pifTerm ‚âù
 match t with
 [ val_to_term v ‚áí val_to_term (rename_aux_v x x' v)
 | appl t1 t2 ‚áí appl (rename_aux x x' t1) (rename_aux x x' t2)
 ]
 
and rename_aux_v (x: Variable) (x':Variable) (v:pifValue) on v ‚âù
 match v with
 [ pvar y ‚áí match veqb x y with [true ‚áí pvar x' | false ‚áí pvar y]
 | abstr y t ‚áí match veqb x y with [true ‚áí abstr x' t | false ‚áí abstr y (rename_aux x x' t)]
 ]
 .
 
let rec rename x x' t on t‚âù 
 match t with
 [ val_to_term v ‚áí val_to_term (rename_v x x' v)
 | appl t1 t2 ‚áí appl (rename x x' t1) (rename x x' t2)
 ]
 
and rename_v x x' v on v‚âù
 match v with
 [ pvar y ‚áí pvar y
 | abstr y t ‚áí match veqb x y with [true ‚áí abstr x' (rename_aux x x' t) | false ‚áí abstr y (rename x x' t)]
 ]
 .
 
let rec t_size t on t ‚âù
 match t with
 [ val_to_term v ‚áí v_size v
 | appl t1 t2 ‚áí S ((t_size t1) + (t_size t2))
 ]
 
and v_size v on v ‚âù 
 match v with
 [ pvar v ‚áí 1
 | abstr x t ‚áí S (t_size t)
 ]
.

lemma pif_size_not_zero: (‚àÄt. t_size t ‚â• O) ‚àß (‚àÄv. v_size v ‚â• O).
@pifValueTerm_ind
[ #v #H normalize /2/
| #t1 #t2 #H1 #H2 /2/
| #x normalize //
| #t #x #H normalize //
]
qed.

lemma pif_subst_axu1: (‚àÄt. S (t_size t -1)=t_size t) ‚àß (‚àÄv. S (v_size v -1)=v_size v).
@pifValueTerm_ind
[ #v #H normalize //
| #t1 #t2 #H1 #H2 normalize //
| #x normalize //
| #t #x #H normalize //]
qed. 
 
lemma rename_aux_lemma: 
 (‚àÄt.‚àÄx,y. t_size t = t_size (rename_aux x y t)) ‚àß
  (‚àÄv.‚àÄx,y. v_size v = v_size (rename_aux_v x y v)).

@pifValueTerm_ind
[ #v #H #x #y normalize >(H x y) //
| #t1 #t2 #H1 #H2 #x #y normalize >(H1 x y) >(H2 x y) //
| #t #x #y normalize cases (veqb x t) normalize //
| #t #x #H #x' #y normalize cases (veqb x' x) normalize //
] qed.

lemma rename_lemma: 
 (‚àÄt.‚àÄx,y. t_size t = t_size (rename x y t)) ‚àß
  (‚àÄv.‚àÄx,y. v_size v = v_size (rename_v x y v)).
 @pifValueTerm_ind

[ #v #H #x #y normalize >(H x y) //
| #t1 #t2 #H1 #H2 #x #y normalize >(H1 x y) >(H2 x y) //
| #v #x #y normalize //
| #t #x #H #x' #y normalize cases (veqb x' x) normalize
  [ lapply rename_aux_lemma * #Haux #_ >(Haux t x' y ) // 
  | >(H x' y) //
  ]
] qed.

theorem ex_falso: ‚àÄP: Prop. False ‚Üí P.
#P #False @(False_ind ‚Ä¶ P) assumption qed.

lemma leq_zero: ‚àÄn. S n ‚â§ O ‚Üí False.
#n elim n normalize [/2/ | #m #H /2/] qed.

(*
let rec pif_subst (n: nat) s: Œ†t. (t_size t ‚â§ n) ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (pi1ps s) t) * ((t_size (pi2ps s)) - 1)‚âù
 match n return Œªn. Œ†t. (t_size t ‚â§ n) ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (pi1ps s) t) * ((t_size (pi2ps s)) - 1) with
 [ O ‚áí Œªt.?
 | S m ‚áí Œªt. match t return Œªt.t_size t ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (pi1ps s) t) * ((t_size (pi2ps s)) - 1) with
   [ val_to_term v ‚áí Œªp. mk_Sig ‚Ä¶ (Sig_fst ‚Ä¶ (pif_subst_v m s v ?)) ? 
   | appl t' u ‚áí  Œªp. mk_Sig ‚Ä¶ (appl (Sig_fst ‚Ä¶ (pif_subst m s t' ? )) (Sig_fst ‚Ä¶ (pif_subst m s u ?))) ?
   ] 
 ]

and pif_subst_v (n: nat) s: Œ†v. (v_size v  ‚â§ n) ‚Üí Œ£u: pifTerm. t_size u = (v_size v)+ (free_occ_v (pi1ps s) v) * ((t_size (pi2ps s)) - 1) ‚âù
 match n return Œªn. Œ†v.v_size v ‚â§ n ‚Üí Œ£u: pifTerm. t_size u = (v_size v)+ (free_occ_v (pi1ps s) v) * ((t_size (pi2ps s)) - 1) with
 [ O ‚áí Œªv.?
 | S m ‚áí Œªv. match v return Œªv. v_size v ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size v)+ (free_occ_v (pi1ps s) v) * ((t_size (pi2ps s)) - 1) with
              [ pvar x ‚áí match s return Œªs. v_size (pvar x) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size (pvar x))+ (free_occ_v (pi1ps s) (pvar x)) * ((t_size (pi2ps s)) - 1) with 
                              [psubst y t' ‚áí Œªp.mk_Sig ‚Ä¶ (match veqb y x with [true ‚áí t' | false ‚áí (val_to_term (pvar x))]) ?
                              ] 
              | abstr x t1 ‚áí  match s return Œªb. v_size (abstr x t1) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size (abstr x t1))+ (free_occ_v (pi1ps s) (abstr x t1)) * ((t_size (pi2ps s)) - 1) with 
                                  [ psubst y t' ‚áí match veqb y x return Œªb. v_size (abstr x t1) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size (abstr x t1))+ (free_occ_v (pi1ps s) (abstr x t1)) * ((t_size (pi2ps s)) - 1) with 
                                                  [ true ‚áí Œªp. mk_Sig ‚Ä¶ (val_to_term v) ?
                                                  | false ‚áí match fvb_t x t' return Œªb. v_size (abstr x t1) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size (abstr x t1))+ (free_occ_v (pi1ps s) (abstr x t1)) * ((t_size (pi2ps s)) - 1) with
                                                            [ true ‚áí match (pif_subst m (psubst x (val_to_term (pvar ŒΩ(fresh_var_t t')))) t1 ?) return Œªb. v_size (abstr x t1) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (v_size (abstr x t1))+ (free_occ_v (pi1ps s) (abstr x t1)) * ((t_size (pi2ps s)) - 1) with 
                                                                      [ mk_Sig a h ‚áí Œªp. mk_Sig ‚Ä¶ (val_to_term (abstr (ŒΩ(fresh_var_t t')) (Sig_fst ‚Ä¶ (pif_subst m (psubst y a) t1 ?)))) ?]
                                                            | false ‚áí Œªp. mk_Sig ‚Ä¶ (val_to_term (abstr x (Sig_fst ‚Ä¶ (pif_subst m s t1 ?)))) ?
                                                            ]
                                                  ]
                                  ]
              ]
]
.
*)



let rec pif_subst (n: nat) s: Œ†t. (t_size t ‚â§ n) ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (match s with [psubst x t ‚áí x]) t) * ((t_size (match s with [psubst x t ‚áí t])) - 1)‚âù
 match n return Œªn. Œ†t. (t_size t ‚â§ n) ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (match s with [psubst x t ‚áí x]) t) * ((t_size (match s with [psubst x t ‚áí t])) - 1) with
 [ O ‚áí Œªt.?
 | S m ‚áí Œªt. match t return Œªt.t_size t ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size t)+ (free_occ_t (match s with [psubst x t ‚áí x]) t) * (t_size (match s with [psubst x t ‚áí t]) - 1) with
   [ val_to_term v ‚áí match v return Œªv. t_size (val_to_term v) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size (val_to_term v))+ (free_occ_v (match s with [psubst x t ‚áí x]) v) * ((t_size (match s with [psubst x t ‚áí t])) - 1) with
              [ pvar x ‚áí match s return Œªs. t_size (val_to_term (pvar x)) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size (val_to_term (pvar x)))+ (free_occ_v (match s with [psubst x t ‚áí x]) (pvar x)) * ((t_size (match s with [psubst x t ‚áí t])) - 1) with 
                              [psubst y t' ‚áí match veqb y x return Œªb. veqb y x = b ‚Üí t_size (val_to_term (pvar x)) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size (val_to_term (pvar x)))+ (free_occ_v y (pvar x)) * ((t_size t') - 1)  with
                               [true ‚áíŒªH.Œªp.mk_Sig ‚Ä¶ t' ? | false ‚áí ŒªH.Œªp.mk_Sig ‚Ä¶ (val_to_term (pvar x)) ?] (refl ‚Ä¶)
                              ] 
              | abstr x t1 ‚áí match veqb (match s with [psubst x t ‚áí x]) x return Œªb. veqb (match s with [psubst x t ‚áí x]) x = b ‚Üí t_size (val_to_term (abstr x t1)) ‚â§ S m ‚Üí Œ£u: pifTerm. t_size u = (t_size (val_to_term (abstr x t1)))+ (free_occ_v match s with [psubst x t ‚áí x] (abstr x t1)) * ((t_size match s with [psubst x t ‚áí t]) - 1)  with
                                                  [ true ‚áí ŒªH.Œªp. mk_Sig ‚Ä¶  (val_to_term (abstr x t1)) ?
                                                  | false ‚áí match fvb_t x (match s with [psubst x t ‚áí t]) with
                                                            [ true ‚áí let z ‚âù (max (fresh_var_t t1) (fresh_var_t match s with [psubst x t ‚áí t])) in match (pif_subst m (psubst x (val_to_term (pvar ŒΩ(z)))) t1 ?) with 
                                                                      [ mk_Sig a h ‚áí ŒªH. Œªp. mk_Sig ‚Ä¶  (val_to_term (abstr (ŒΩ(z)) (pi1 ‚Ä¶ (pif_subst m s a ?)))) ?]
                                                            | false ‚áí ŒªH.Œªp. mk_Sig ‚Ä¶ (val_to_term (abstr x (pi1 ‚Ä¶ (pif_subst m s t1 ?)))) ?
                                                            ]
                                                  ] ?
              ]
   | appl t' u ‚áí  Œªp. mk_Sig ‚Ä¶ (appl (pi1 ‚Ä¶(pif_subst m s t' ? )) (pi1 ‚Ä¶ (pif_subst m s u ?))) ?
   ] 
 ]
 .
[ cases t [ #v cases v [#x normalize #Abs lapply (leq_zero 0 Abs) -Abs #Abs elim Abs
          | #x #t normalize #Abs lapply (leq_zero (t_size t) Abs) -Abs #Abs elim Abs]
| #t1 #t2 normalize #Abs lapply (leq_zero ((t_size t1)+(t_size t2)) Abs) -Abs #Abs elim Abs]
| normalize in p; normalize >H normalize <(plus_n_O (t_size t' -1)) lapply(pif_subst_axu1) * #H #_ >(H t') // 
| normalize cases s #y #t' normalize >H normalize in p; normalize //
| cases s normalize //
| lapply H cases s #x #t normalize #H1 >H1 normalize //
| normalize in h; normalize in p; /2/
| cases s #y #t' whd in match (match¬†psubst y t'¬†in¬†pifSubst¬†return¬†Œª_:pifSubst.Variable¬†with¬†
         [psubst (x0:Variable) ¬† (t0:pifTerm)‚áíx0]) ;
  normalize in match (t_size
           match¬†psubst y t'¬†in¬†pifSubst¬†return¬†Œª_:pifSubst.pifTerm¬†with¬†
           [psubst (x0:Variable) ¬† (t0:pifTerm)‚áít0]
           -1);
 normalize
 
| lapply (pif_subst m s t1)
 4,5,7,8: normalize in p; oiuy
| cases s #y #t' normalize cut (veqb y x =true ‚à® veqb y x = false) // * #Hyx >Hyx
 [ normalize // | cut (gtb (free_occ_t x t') O¬†= true ‚à® gtb (free_occ_t x t') O¬†= false) // * #Hfv >Hfv
  [ normalize | normalize lapply (pif_subst m (psubst y t') t1) #H normalize in H;
  [ ]


(*
let rec c_size c on c ‚âù
 match c with
 [ CCrumble b e ‚áí c_size_b b + c_size_e e ]

and

c_size_b b on b ‚âù
 match b with
 [ CValue v ‚áí c_size_v v
 | AppValue v w ‚áí c_size_v v + c_size_v w
 ]

and

c_size_e e on e ‚âù
 match e with
 [ Epsilon ‚áí O
 | Cons e s ‚áí S (c_size_e e)
 ]

and

c_size_v v on v ‚âù
 match v with
 [ var x ‚áí O
 | lambda x c ‚áí c_size c
 ]
 .*)

let rec c_size c on c ‚âù
 match c with
 [ CCrumble b e ‚áí S (c_size_b b + c_size_e e) ]

and

c_size_b b on b ‚âù
 match b with
 [ CValue v ‚áí c_size_v v
 | AppValue v w ‚áí S (c_size_v v + c_size_v w)
 ]

and

c_size_e e on e ‚âù
 match e with
 [ Epsilon ‚áí O
 | Cons e s ‚áí(c_size_e e) + c_size_s s
 ]

and

c_size_v v on v ‚âù
 match v with
 [ var x ‚áí S O
 | lambda x c ‚áí S (c_size c)
 ]

and

c_size_s s on s ‚âù
 match s with
 [ subst x b ‚áí S (c_size_b b)]
 .

let rec c_len_e e on e ‚âù match e with [Epsilon ‚áí O | Cons e s ‚áí 1 + c_len_e e].

let rec c_len c on c ‚âù
 match c with
 [ CCrumble b e ‚áí c_len_e e].

let rec e_pop e on e ‚âù
 match e with
 [ Epsilon ‚áí e
 | Cons e s ‚áí e
 ]
 .

let rec fv_pt x t on t‚âù
 match t with
 [ val_to_term v ‚áí fv_pv x v
 | appl t1 t2 ‚áí  orb (fv_pt x t1) (fv_pt x t2)
 ]

and fv_pv x v on v ‚âù
 match v with
 [ pvar y ‚áí veqb x y
 | abstr y t ‚áí if veqb x y then false else fv_pt x t
 ]
 .

lemma env_len: ‚àÄe: Environment. (e = Epsilon ‚Üí False ) ‚Üí  S (c_len_e (e_pop e))=(c_len_e e).
#e cases e [ normalize #Abs cut False [ cut (Epsilon=Epsilon) [ //| @Abs] | #Abs
@False_ind] @Abs | #e1 #s #H1 normalize //] qed.

lemma succ_eq: ‚àÄn, m:nat. S n = S m ‚Üí n = m.
#n #m #H destruct // qed.

lemma subtr_1: ‚àÄa,b,c:nat. a+b-(a+c)=b-c.
#a #b #c elim a // qed.

(* Definizione 1: na√Øve, restituisce il clasico errore: *)
(* NTypeChecker failure: Recursive call (read_back_b b), b is not smaller.

let rec read_back x on x ‚âù
 match x with
 [ CCrumble b e ‚áí match e with
                  [ Epsilon ‚áí read_back_b b
                  | Cons e1 s ‚áí match s with [ subst x' b1 ‚áí pif_subst (read_back ‚å©b, e1‚å™) (psubst x' (read_back_b b1))]
                  ]
 ]

and

read_back_b b ‚âù
 match b with
 [ CValue v ‚áí read_back_v v
 | AppValue v w ‚áí appl (read_back_v v) (read_back_v w)
 ]

and

read_back_v v ‚âù
 match v with
 [ var x ‚áí val_to_term (pvar x)
 | lambda x c ‚áí val_to_term (abstr x (read_back c))
 ]
 .
*)

(* Definizione 2: come da lei consigliato, spezzo la read_back c in read_back b e *)
(* in modo che l'induzione su e mi assicuri la diminuzione della dimensione del termine*)
(* purtroppo per√≤, la chiamata ricorsiva sul byte non mi assicura che la dimensione diminuisca*)
(* suppongo che questo sia dovuto al fatto che un byte pu√≤ a sua volta contenere un  *)
(* crumble la cui dimensione √® arbitraria *)

(*
let rec aux_read_back rbb e on e ‚âù
 match e with
 [ Epsilon ‚áí rbb
 | Cons e1 s ‚áí match s with [ subst x' b1 ‚áí pif_subst (aux_read_back rbb e1) (psubst x' (read_back_b b1))]
 ]

and

read_back_b b ‚âù
 match b with
 [ CValue v ‚áí read_back_v v
 | AppValue v w ‚áí appl (read_back_v v) (read_back_v w)
 ]

and

read_back_v v ‚âù
 match v with
 [ var x ‚áí val_to_term (pvar x)
 | lambda x c ‚áí match c with
                [ CCrumble b e ‚áí val_to_term (abstr x (aux_read_back (read_back_b b) e))]
 ]
 .

let rec read_back c on c ‚âù
 match c with
 [ CCrumble b e ‚áí aux_read_back (read_back_b b) e]
 .
*)
(* Definizione 3: ragionevolmente giusta, ma d√† il seguente errore: read_back_b b *)
(* is not smaller. Faccio fatica a capirne il motivo, perch√© il fatto che la *)
(* lunghezza degli environment dei crumble di livello pi√π esterno diminuisca ad *)
(* ogni chiamata, dovrebbe assicurare la terminazione, ma suppongo anche *)
(* che Matita si aspetti che le chiamate per induzione sulla dimensione di *)
(* un termine abbiano come taglia un intero sempre decrescente, cosa che, con *)
(* la definizione di taglia data da c_len non si verifica. L'errore, dunque, *)
(* dovrebbe somigliare a quello del punto precedente.
*)

(*
let rec read_back (n: nat) : Œ†c: Crumble. c_len c = n ‚Üí pifTerm ‚âù
 match n return Œªn.Œ†c: Crumble. c_len c = n ‚Üí pifTerm with
 [ O ‚áí Œªc. match c return Œªc.c_len c = O ‚Üí pifTerm with
          [ CCrumble b e ‚áí Œªp.(read_back_b b)]
 | S m ‚áí Œªc. match c return Œªc.c_len c = S m ‚Üí pifTerm with
    [ CCrumble b e ‚áí match e with
        [ Epsilon ‚áí  Œªabs.(read_back_b b)
        | Cons e1 s ‚áí Œªp.match s with [ subst x' b1 ‚áí pif_subst (read_back m ‚å©b, e_pop e‚å™ ?) (psubst x' (read_back_b b1))]
        ]
    ]
 ]

and

read_back_b b ‚âù
 match b with
 [ CValue v ‚áí read_back_v v
 | AppValue v w ‚áí appl (read_back_v v) (read_back_v w)
 ]

and

read_back_v v ‚âù
 match v with
 [ var x ‚áí val_to_term (pvar x)
 | lambda x c ‚áí val_to_term (abstr x (read_back (c_len c) c (refl ‚Ä¶)))
 ]
 .

lapply p
normalize cases e normalize [ #H destruct | #e1 #s1 // ]
qed.
*)

(* Definizione 4: provo a definire una funzione size pi√π accurata: la taglia *)
(* di un crumble equivale alla lunghezza ti tutti gli environment in esso *)
(* annidati ney byte al primo membro. In questo modo dovrei riuscire ad evitare l'errore perch√© *)
(* la suddetta definizione mi garantirebbe la diminuzione della taglia del *)
(* termine ad ogni chiamata ricorsiva. Ma quando vado a fornire la dimostrazione *)
(* mi si solleva un altro problema: come faccio ad esprimere il fatto che e = Cons e1 s ?
*)
(*

let rec read_back (n: nat) : Œ†c: Crumble. c_size c = n ‚Üí pifTerm ‚âù
 match n return Œªn.Œ†c: Crumble. c_size c = n ‚Üí pifTerm with
 [ O ‚áí Œªc.Œªabs. ?
 | S m ‚áí Œªc. match c return Œªc.c_size c = S m ‚Üí pifTerm with
    [ CCrumble b e ‚áí match e return Œªe. c_size (CCrumble b e) = S m ‚Üí pifTerm with
      
        [ Epsilon ‚áí  Œªp.(read_back_b (m) b (?))
        | Cons e1 s ‚áí match s return Œªs. c_size (CCrumble b (Cons e1 s)) = S m ‚Üí pifTerm with [ subst x' b1 ‚áí Œªp. pif_subst (read_back ((S m) - (c_size_s [x'‚Üê b1])) ‚å©b, e1‚å™ ?) (psubst x' (read_back_b (m - c_size ‚å©b, e1‚å™) b1 ?))]
        ]
    ]
 ]


and

read_back_b (n: nat): Œ†b: Byte. c_size_b b = n ‚Üí pifTerm ‚âù
 match n return Œªn.Œ†b: Byte. c_size_b b = n ‚Üí pifTerm with
 [ O ‚áí Œªb. match b return Œªb. c_size_b b = O ‚Üí pifTerm with
    [ CValue v ‚áí Œªp. read_back_v (c_size_v v) v (refl ‚Ä¶)
    | AppValue v w ‚áí Œªabs. ?
    ]
 | S m ‚áí Œªb. match b return Œªb. c_size_b b = S m ‚Üí pifTerm with
    [ CValue v ‚áí Œªp. read_back_v (c_size_v v) v (refl ‚Ä¶)
    | AppValue v w ‚áí Œªp. appl (read_back_v (c_size_v v) v (refl ‚Ä¶)) (read_back_v (c_size_v w) w (refl ‚Ä¶))
    ]
 ]

and

read_back_v (n: nat): Œ†v: Value. c_size_v v = n ‚Üí pifTerm‚âù
 match n return Œªn.Œ†v: Value. c_size_v v = n ‚Üí pifTerm with
 [ O ‚áí Œªv. match v return Œªv. c_size_v v = O ‚Üí pifTerm with
     [ var x ‚áí Œªp.val_to_term (pvar x)
     | lambda x c ‚áí Œªp.val_to_term (abstr x (read_back (c_size c) c (refl ‚Ä¶)))
     ]
 | S m ‚áí Œªv. match v return Œªv. c_size_v v = S m ‚Üí pifTerm with
     [ var x ‚áí Œªp. val_to_term (pvar x)
     | lambda x c ‚áí Œªp. val_to_term (abstr x (read_back (c_size c) c (refl ‚Ä¶)))
     ]
 ]

 .
 
 
(*
[lapply p normalize cases (c_size_b b) [ normalize // | #n cases (c_size_e e1) [
#H // | #p #H cut (S ((S n)+(S p))=S m) [ // | @succ_eq] ] ]  qed.
*)
[ lapply abs cases c #b #e normalize cases (b) [ #v cases (v)[ #x normalize #abs
destruct | #x #d normalize #abs destruct] | #v #w normalize #abs destruct ]
| lapply p normalize //
| normalize in p; destruct normalize cases (c_size_b b1)
 [ normalize // | #q normalize /2/]
|  lapply p normalize #H destruct /2/
| normalize in abs; destruct] qed.
*)
(*
lemma value_lemma: ‚àÄv: pifValue. read_back_v (overline v) = val_to_term v.
#v cases v
 [ #x normalize //
 | #x #t elim x #nx cases nx
  [ normalize cases t [ normalize #v'
*)
(*
lemma c4: ‚àÄe: Environment. ‚àÄx:Variable. ((has_member (dom_list e) x) = false)  ‚Üí ((has_member (fv_env e) x) = false) ‚Üí
          ‚àÄc: Crumble. ‚àÄb: Byte. read_back (at c (push e [x‚Üêb]))= pif_subst (read_back (at c e)) (psubst x  (read_back ‚å©b, e‚å™)).
#e #x #H1 #H2 #c #b elim c
*)

definition ol ‚âù Œªv. fst Value nat (overline v (fresh_var_tv v)).
definition ul ‚âù Œªt. fst Crumble nat (underline_pifTerm t (fresh_var_t t)).



lemma leq1: ‚àÄa, b, c.‚àÄP:Prop. a‚â§b ‚Üí (a ‚â§ b+c ‚Üí P )‚Üí P.
#a #b #c #P #H1 #H2 cut (b‚â§b+c)
 [ // |  #H3 cut (a‚â§b+c) [ @(transitive_le ? (b)) // | #H4 @(H2 H4)]] qed.

lemma le_plus_a_r: ‚àÄa,n,m. n ‚â§ m ‚Üí n ‚â§ m + a.
/2/ qed.

lemma le_aux1: ‚àÄa, b. leb a b = false ‚Üí b < a.
#a #b #H lapply (leb_false_to_not_le ‚Ä¶ H) #H @(not_le_to_lt ‚Ä¶ H) qed.

lemma le_aux2: ‚àÄm: nat. ‚àÄP: Prop. ((0 ‚â§ m) ‚Üí P) ‚Üí P.
#m #P #H cut (‚àÄn. 0‚â§n) [ #n cases n //| #H1 @(H (H1 m))] qed.

lemma max_O: ‚àÄx. max x O = x.
#x cases x //. qed.

lemma and_true: ‚àÄx. (x ‚àß true) = x.
#x cases x // qed.

lemma or_false: ‚àÄx. (x ‚à® false) = x.
#x cases x // qed.

lemma max_n_m: ‚àÄn,m. max n m =n ‚à® max n m = m.
#n #m cases n [ normalize //| cases m #nn 
 [ normalize /2/ | #mm normalize cases (leb mm nn) normalize /2/] qed.

lemma if_leb_x_O: ‚àÄx. if (leb x O) then O else x =x.
#x cases x normalize [// |#m //] qed.

lemma veqb_comm: ‚àÄx.‚àÄy. veqb x y  = veqb y x.
#x #y elim x #nx elim y #ny normalize //. qed.

lemma lt_to_le: ‚àÄn, m. n<m ‚Üí n ‚â§ m.
/2/ qed.

lemma veqb_trans: ‚àÄx,y,z. (veqb x y) = true ‚Üí (veqb y z) = true ‚Üí (veqb x z)=true.
#x #y #z lapply ((veqb_true_to_eq x y)) #H1 lapply ((veqb_true_to_eq y z)) #H2
#H3 #H4 normalize in H1; normalize in H2; cut (x=z)
[ @(And_ind ‚Ä¶ H1) #H1' #H1'' -H1 @(And_ind ‚Ä¶ H2) #H2' #H2'' -H2 lapply (H1' H3) lapply (H2' H4) //
| #H destruct -H1 -H2 -H3 -H4 elim z #nz normalize //] qed.

lemma veqb_simm: ‚àÄx,y. (veqb x y) = veqb y x.
#x #y elim x #nx elim y #ny normalize /2/ qed. 

lemma veqb_true: ‚àÄx. veqb x x = true.
#x elim x #nx elim nx normalize // qed.

lemma veqb_fv: ‚àÄx,z.‚àÄt. veqb x z =true ‚Üí  fvb_t x t = fvb_t z t. 
#x #z #t #h lapply (veqb_true_to_eq x z) normalize #H @(And_ind ‚Ä¶ H) -H
#H' #H'' lapply (H' h) #Heq destruct //. qed.

lemma if_id_f: if false then true else false = false. // qed.
lemma if_id_t: if true then true else false = true. // qed.

lemma if_not_t: if true then false else true = false. // qed.  
lemma if_not_f: if false then false else true = true. // qed.

lemma if_t: ‚àÄA.‚àÄx:A.‚àÄy:A. if true then x else y = x.
#A #x #y normalize // qed.

lemma if_f: ‚àÄA.‚àÄx:A.‚àÄy:A. if false then x else y = y.
#A #x #y normalize // qed. 

lemma pif_subst_fv_lemma: 
 (‚àÄt.‚àÄx.‚àÄt'.‚àÄy. fvb_t y (pif_subst (t) (psubst x t')) = ((fvb_t x t) ‚àß (fvb_t y t') ‚à® (fvb_t y t) ‚àß ¬¨(veqb x y))) ‚àß 
  (‚àÄv. ‚àÄx. ‚àÄt'.‚àÄy. fvb_t y (pif_subst_v v (psubst x t')) = ((fvb_tv x v) ‚àß (fvb_t y t') ‚à® (fvb_tv y v)‚àß ¬¨(veqb x y))).

  
@pifValueTerm_ind
[ #pV #H assumption 
| #t1 #t2 #H1 #H2 #x #t' #y normalize >(H1 x t' y) >(H2 x t' y) cases (fvb_t y t2) cases (fvb_t y t1) cases (fvb_t y t') cases (fvb_t x t1) cases (fvb_t x t2) cases (veqb x y) normalize //
| #z #x #t' #y cut (veqb x z=true ‚à® veqb x z=false) // cut (veqb y z=true ‚à® veqb y z=false) // * #H1 * #H2  
   [ lapply(veqb_true_to_eq ‚Ä¶ x z) * #Heq #_ lapply (Heq H2) -Heq #Heq destruct
     >H2 -H2 lapply (veqb_true_to_eq y z) * #Heq #_ lapply (Heq H1) -Heq #Heq
     destruct normalize >H1 normalize cases (fvb_t z t') //
   | normalize >H2 lapply(veqb_true_to_eq ‚Ä¶ y z) * #Heq #_ lapply (Heq H1) -Heq #Heq destruct >H1
     normalize >H2 normalize assumption
   | lapply(veqb_true_to_eq ‚Ä¶ x z) * #Heq #_ lapply (Heq H2) -Heq #Heq destruct
   normalize >H2 normalize >H1 normalize cases (fvb_t y t') //
   | cut (veqb x y = true ‚à® veqb x y =false) // * #H3
     [ lapply (veqb_true_to_eq ‚Ä¶ x y) * #Heq #_ lapply (Heq H3) -Heq #Heq destruct
     normalize >H2 >H3 normalize assumption
     | normalize >H1 >H2 >H3 normalize assumption
   ]
   ]
| #t #z #H1 #x #t' #y normalize cut (veqb x z = true ‚à® veqb x z= false) // * #Hxz
  >Hxz normalize  cut (veqb x y = true ‚à® veqb x y= false) // * #Hxy >Hxy normalize
  [ lapply (veqb_true_to_eq ‚Ä¶ x y) * #Heq #_ lapply (Heq Hxy) -Heq #Heq destruct
    lapply (veqb_true_to_eq ‚Ä¶ y z) * #Heq #_ lapply (Heq Hxz) -Heq #Heq destruct
    >Hxz normalize //
  | lapply (veqb_true_to_eq ‚Ä¶ x z) * #Heq #_ lapply (Heq Hxz) -Heq #Heq destruct
    >(veqb_simm y z) >Hxy normalize cases (fvb_t y t) //
  | lapply (veqb_true_to_eq ‚Ä¶ x y) * #Heq #_ lapply (Heq Hxy) -Heq #Heq destruct
    >Hxz normalize cut (fvb_t z t =true ‚à® fvb_t z t=false) // * #Hfvzt >Hfvzt
    normalize


lemma fv_lemma: 
 (‚àÄc.‚àÄx. fvb x c = fvb_t x (read_back c)) ‚àß
  (‚àÄb.‚àÄx. fvb_b x b = fvb_t x (read_back_b b)) ‚àß
   (‚àÄe.‚àÄb.‚àÄx. fvb_b x b = fvb_t x (read_back_b b) ‚Üí fvb x ‚å©b, e‚å™ = fvb_t x (read_back ‚å©b,e‚å™)) ‚àß
    (‚àÄv.‚àÄx. fvb_v x v = fvb_t x (read_back_v v)) ‚àß
     (‚àÄs.‚àÄb.‚àÄe.‚àÄx. fvb_b x b = fvb_t x (read_back_b b) ‚Üí  fvb x ‚å©b, (Cons e s)‚å™ = fvb_t x (read_back ‚å©b, (Cons e s)‚å™)).

@Crumble_mutual_ind
[ #b #e #H1 #H2 #x lapply (H1 x) lapply (H2 b x) /2/
| #v #H normalize assumption
| #v #w #H1 #H2 #x normalize >(H1 x) >(H2 x) //
| #x #y normalize //
| #x #c cases c #b #e normalize #H #y lapply (H y) >(veqb_comm y x) elim (veqb x y) normalize
 [ #Hinutile  // | #Hutile @Hutile] 
| #b #x normalize #H <H cases (fvb_b x b) //  
| #e #s #H1 #H2 #b #x #H3 @(H2 b e x) //
| #x #b #H #b' #e #y #H1  normalize cases e normalize cases (read_back_b b')
 [ #v
 


lemma fesh_lemma:
 (‚àÄc. fresh_var c = fresh_var_t (read_back c)) ‚àß
  (‚àÄb. fresh_var_b b = fresh_var_t (read_back_b b)) ‚àß
   (‚àÄe.‚àÄb. fresh_var ‚å©b, e‚å™ = fresh_var_t (read_back ‚å©b,e‚å™)) ‚àß
    (‚àÄv. fresh_var_v v = fresh_var_t (read_back_v v)) ‚àß
     (‚àÄs.‚àÄb.‚àÄe. fresh_var ‚å©b, (Cons e s)‚å™ = fresh_var_t (read_back ‚å©b, (Cons e s)‚å™)).

@Crumble_mutual_ind
[ #b #e #H1 #H2 lapply (H2 b) -H2 #H2 assumption
| #v #H normalize assumption
| #v #w #H1 #H2 normalize change with (max ? ?) in match  (if ? then ? else ?) in ‚ä¢ % ;
  change with (max ? ?) in match (if¬†leb (fresh_var_t (read_back_v v)) (fresh_var_t (read_back_v w))¬† then¬†? else¬†?¬†) in ‚ä¢%;
  >H1 >H2 //
| #x normalize //
| #x #c elim x #nx cases c #b #e normalize change with (max ? ?) in match  ( if¬†leb (fresh_var_b b) (fresh_var_e e)¬† then ? else ?) in ‚ä¢ % ;
  #H >H //
| #b normalize change with (max ? ?) in match  ( if¬†? then ? else ?) in ‚ä¢ %; >max_O
 [ #v normalize cases v
  [ #x normalize //
  | #x #c elim x #nx cases c #b #e normalize change with (max ? ?) in match  ( if leb¬†? ? then ? else ?) in ‚ä¢ %;
  
   #s #H1 #H2 #b @ (H2 b e)
| #x #b #H #b #e normalize 
 #b normalize cases b
 [#v normalize change with (max ? ?) in match  ( if¬†? then ? else ?) in ‚ä¢ %; >max_O cases v #x normalize //
  #c elim x #nx normalize cases c #b #e change with (max ? ?) in match  ( if¬†leb (fresh_var_b b) (fresh_var_e e)¬† then ? else ?) in ‚ä¢ % ;
  normalize
  change with (fresh_var_v (lambda (ŒΩ?) ‚å©?, ? ‚å™)) in match  ( if¬†? then ? else ?) in ‚ä¢ %;
  change with (fresh_var_tv (abstr (ŒΩ?) ‚å©?, ? ‚å™)) in match  ( if¬†? then ? else ?) in ‚ä¢ %;
  case


     
lemma value_lemma:
  ‚àÄv: pifValue. ‚àÄ n. n ‚â• fresh_var_tv v ‚Üí
  match (overline v n) with
   [ mk_Prod v' m ‚áí (read_back_v v') = (val_to_term v) ‚àß (m + n ‚â• (fresh_var_v v')) ].

#v @(pifValue_ind ‚Ä¶ v)
[ @(Œªt. ‚àÄn. n ‚â• fresh_var_t t ‚Üí
  match (underline_pifTerm t n) with
  [ mk_Prod c m ‚áí read_back c = t ‚àß m+n ‚â• fresh_var c])
| #v0 cases v0 (*devo dimostrare per ogni v0*)
 [#x elim x #nx normalize /2/
 | #x elim x #nx #t normalize #HI #m lapply (HI m ) cases (underline_pifTerm t m)
   #c #fv_c normalize cases c #b #e normalize
   change with (max ? ?) in match  (if leb ? ? then ? else ?) in ‚ä¢ % ;
   cases fresh_var_t normalize
   change with (max ? ?) in match  (if leb ? ? then ? else ?) in ‚ä¢ % ;
   cases (max (fresh_var_b b) (fresh_var_e e))
   normalize
   change with (max ? ?) in match  (if leb ? ? then ? else ?) in ‚ä¢ % ;
   [ normalize #H @H
   | #n cases¬†(leb nx n) normalize #H @H
   | #n #H @H
   | #n #m cases (leb nx n) normalize #H @H 
   ]
 ]
| #t1 #t2 cases t2
 [ #v2 cases t1
  [ #v1 normalize #H1 #H2 #n lapply (H1 n) cases (overline v1 n) #vv #m lapply (H2 (n+m)) normalize
    cases (overline v2 (n+m)) #ww #mm normalize
    change with (max ? ?) in match  (if ? then ? else ?) in ‚ä¢ % ;
    change with (max ? ?) in match  (if leb (fresh_var_tv v1) (fresh_var_tv v2)¬†then ? else ?) in ‚ä¢ % ;
    change with (max ? ?) in match  (if leb (fresh_var_v ?) (fresh_var_v ?)¬†then ? else ?) in ‚ä¢ % ;
    >max_O
    change with (max ? ?) in match  (if ? then ? else ?) in ‚ä¢ % ;
    >max_O
    -H1 -H2 #H1 #H2 #H3 lapply (le_maxl ? ? ? H3) #H4 lapply (H2 H4) -H2 #H2 -H4 lapply (le_maxr ? ? ? H3) #H5
    lapply (H1 (le_plus_a_r ‚Ä¶ H5)) -H1 -H5 #H1 >if_leb_x_O 
    @(And_ind ‚Ä¶ H1) @(And_ind ‚Ä¶ H2) -H1 -H2 #H1 #H1' #H2 #H2' 
    %[ >H1 >H2 // | cut (max (fresh_var_v vv) (fresh_var_v ww) =(fresh_var_v vv) ‚à® max (fresh_var_v vv) (fresh_var_v ww)= (fresh_var_v ww))
     [ @max_n_m | #Hor elim Hor -Hor #Hor >Hor [ /2/ | /2/   ]]]
| #u1 #u2  #H1 #H2 #n lapply (H1 n) whd in match (underline_pifTerm ? ?) in ‚ä¢ (? ‚Üí %); -H1 cases (underline_pifTerm (appl u1 u2) n)
#c #m normalize lapply (H2 (n+m)) cases (overline v2 (n+m)) #vv #mm
change with (max ? ?) in match  (if leb ? ? then ? else ?) in ‚ä¢ % ;
change with (max ? ?) in match (if leb (max ? ?) ? then ? else ?) in ‚ä¢ %; -H2
#H2 #H1 #H3
change with (fresh_var_t (appl ? ?)) in match (max (fresh_var_t ?) (fresh_var_t ?)) in H3;
change with (fresh_var_t (val_to_term ?)) in match (fresh_var_tv ?) in H3;
change with (fresh_var_t (appl ? ?)) in match (max (fresh_var_t ?) ?) in H3;
lapply H1 cases c #b #e -H1 #H1 whd in ‚ä¢ %;

 normalize
change with (max ? ?) in match  (if ? then ? else ?) in ‚ä¢ % ;
change with (?) in match (match¬†fresh_var_v vv¬†in¬†nat¬†return¬†Œª_:‚Ñï.bool¬†with¬†
         [O‚áífalse|S (q:‚Ñï)‚áíleb (n+m+mm) q]) in ‚ä¢ %;
 cases (fresh_var_v vv) normalize

lemma term_lemma:
 ‚àÄt: pifTerm. ‚àÄn. n= fresh_var_t t ‚Üí
  match (underline_pifTerm t n) with
  [ mk_Prod c m ‚áí read_back c = t ‚àß m+n=fresh_var c].
#t @(pifTerm_ind ‚Ä¶ t)
[ @(Œªv.‚àÄ n. n = fresh_var_tv v ‚Üí
  match (overline v n) with
   [ mk_Prod v' m ‚áí (read_back_v v') = (val_to_term v) ‚àß (m + n = (fresh_var_v v')) ])
| (*#v cases v [ #x  #Hv normalize cases x #nx normalize /2/
 | #x #t1 elim x #nx normalize cases (fresh_var_t t1)
  [ normalize #H #n #Hn cases (underline_pifTerm t1 n) #c #m normalize*)
| #t1 #t2 #Hind1 #Hind2 #n #Hn cases (underline_pifTerm (appl t1 t2)) #c #m
 normalize


lemma value_lemma: ‚àÄv: pifValue. read_back_v (ol v) = val_to_term v.
#v @(pifValue_ind ‚Ä¶ v)
[ @(Œªt. (read_back (ul t) = t))
| #v0 #Hind normalize lapply Hind cases v0
 [ #x normalize //
 | #x #t normalize cases x normalize #n /2/
|
| #x normalize //
| #t1 #x #Hind elim x #n elim n
 [ normalize lapply Hind cases t1
  [ normalize #v #H >H //
  | #t1 #t2 cases (t1) normalize  #H




 #t1 #t2
